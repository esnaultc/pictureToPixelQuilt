---
output:
  html_document:
    code_folding: hide
    toc: true
    toc_float: true
---


```{r global_options, include = FALSE}
knitr::opts_chunk$set(
	echo=FALSE,
	warning=FALSE,
	message=FALSE)
```

```{r libraries}
library(magick)
library(ggplot2)
library(tidyr)
library(yaml)
library(dplyr)
library(scales)
```


```{r functions}
# deduct the rest of parameters from config and image file
add_params <- function(cfg_i, img_i) {
	# cfg_i: config loaded from yaml file
	# img_i: magick image object

	# image size
	cfg_i[['img_width']] <- list(
		'value' = image_info(img_i)[['width']],
		'description' = 'width in pixel of the image')
	cfg_i[['img_height']] <- list(
		'value' = image_info(img_i)[['height']],
		'description' = 'height in pixel of the image')

	# tile width is the image width divided by requested number of tiles along x-axis
	cfg_i[['tile_width']] <- list(
		'value' = ceiling(cfg_i[['img_width']][['value']] /
			 cfg_i[['tile_number_width']][['value']]),
		'description' = 'tile width in pixel')

	# now can deduct the number of tiles along y-axis
	cfg_i[['tile_number_height']] <- list(
		'value' = ceiling(cfg_i[['img_height']][['value']] / cfg_i[['tile_width']][['value']]),
		'description' = 'number of tiles across the height of the picture')

	# predict the finished size of the quilt
	cfg_i[['finished_size']] <- list(
		'value' = paste0(
			cfg_i[['tile_size']][['value']] * cfg_i[['tile_number_width']][['value']],
			' x ',
			cfg_i[['tile_size']][['value']] * cfg_i[['tile_number_height']][['value']]),
		'description' = 'finished quilt size, in inch')
	return(cfg_i)
}

# crop the image to a tile, given specific position
crop_to_tile <- function(img_i, tile_width, tile_col, tile_row) {
	# img_i: magick image object
	# tile_width: width of the tile, in pixel
	# tile_col: column number of the current tile (along x-axis)
	# tile_row: row number of the current tile (along y-axis)

	# this function uses image_crop() which requires a geometry string
	# of the format: window_width x window_height + x-axis offset + y-axis offset,
	# i.e. 400x400+200+200
	geom_string <- paste0(
		tile_width, "x", 
		tile_width, '+', 
		(tile_col - 1) * tile_width + 1 , '+', 
		(tile_row - 1) * tile_width + 1 )
	return(image_crop(img_i, geometry = geom_string))
}

# given df of coordinates and hex values,
# count the frequency of each color.
# return the dominant color = the one with the highest count
dominant_color <- function(df) {
	df %>%
		group_by(col) %>%
		summarize(total = n()) %>%
  		arrange(desc(total)) %>%
		slice(1) %>%
		.[['col']]
}

# plot in ggplot2 the tiles from a dataframe with the columns x, y, color_name (= cluster)
# and hex value
# return the ggplot
plot_tiles <- function(df, label=FALSE) {
	# custom colors need a named list
	hex_cols <- unique(df$new_hex)
	names(hex_cols) <- hex_cols
	# make a ggplot geom_tile of x by y, with fill = hex
	p <- ggplot(df, aes(x=x, y=-1*y, label=color_name, fill=new_hex)) +
		geom_tile(color = "black", linewidth = 0.2) +
		scale_fill_manual(values=hex_cols) +
		coord_equal() +
		theme_classic() +
		theme(legend.position="none",
		      axis.title.x = element_blank(),
		      axis.title.y = element_blank())
	if (label == TRUE) {
		p <- p + 
			geom_text(aes(label=color_name))
	}
 	return(p)
}

# returns per color the number of tiles and the yardage in fat quarter
get_totals <- function(df) {
	df %>%
		group_by(color_name) %>%
		summarize(number_of_tiles = n(),
			new_hex = first(new_hex)) %>%
		mutate(number_of_fat_quarters = number_of_tiles / tile_in_fq,
	      		y = color_name,
	       		x = 1)
}
```


```{r read_input}
# config,yaml file contains the file to convert and params
cfg <- read_yaml("config.yaml")

# load the image file with magick
img <- image_read(cfg[['img_filename']][['value']])

# add other params that are file-specific and deducted from the file info
cfg <- add_params(cfg, img)
```

## Current parameters

The table below describes the parameters used for generating the pattern.

```{r print_params}
# convert the config to df to print in a table
do.call(rbind, cfg) %>%
	as.data.frame() %>%
	mutate(parameter = rownames(.)) %>%
	arrange(parameter) %>%
	select(parameter, value, description) %>%
	knitr::kable(row.names=FALSE)
```

## Color reduction

Pictures contain often hundreds of colors, many very close in shades. It is necessary to simplify
the color universe of the original picture before calculating the number of occurance of each color.
Without that simplification, the dominant color shades might overwhelm the other colors and bias
the final colorscheme.

Different pictures might behave differently with different colorspace reduction, try another
``colospace`` in the ``config.yaml`` file if the colors look off after reduction. The maximum
number of color after reduction (``colorspace_max_colors`` in the file ``config.yaml``) can also
be adjusted.

```{r decrease_colors, results='asis', fig.width=3}
# the goal of this intermediate step is to decrease the number of colors to a more
# manageable number. 

# set the seed for reproducibility
set.seed(42)

# reduce the colors
reduced_img <- image_quantize(
	img,
	max = cfg[['colorspace_max_colors']][['value']],
	colorspace = cfg[['colorspace']][['value']],
	dither = TRUE,
	treedepth=8)

cat('\n\n### Original picture\n\n')
img %>% image_resize('300')
cat('\n\n### After color reduction\n\n')
reduced_img %>% image_resize('300')
```



```{r split_img}
# Split the image into a raster grid, loop through rows and columns
tiled_imgs <- list()

for (tile_row in 1:cfg[['tile_number_height']][['value']]) {
	for (tile_col in 1:cfg[['tile_number_width']][['value']]) {
		tile_i <- paste0(tile_col, 'x', tile_row)
		tiled_imgs[[tile_i]] <- crop_to_tile(
			reduced_img, cfg[['tile_width']][['value']], tile_col, tile_row)
	}
}
```

```{r get_main_color}
# get the pixel data into a df
pixels <- lapply(tiled_imgs, image_raster)

# get the dominant color per tile, this is the one with the highest count
dominant_color_df <- lapply(pixels, dominant_color) %>%
	as.data.frame(check.names=FALSE) %>%
	t() %>%
	as.data.frame() %>%
	mutate('tile' = rownames(.))

colnames(dominant_color_df) <- c('hex', 'tile')
```

```{r cluster_colors}
# convert to RGB to perform kmeans clustering
dominant_color_df[c('red', 'green', 'blue')] <- lapply(dominant_color_df[['hex']], col2rgb) %>%
	as.data.frame() %>%
	t() %>%
	as.data.frame()

# set the seed so the results are the same every time it is run
set.seed(42)
clusters <-  kmeans(
	dominant_color_df[c('red', 'green', 'blue')],
	 centers=cfg[['color_number']][['value']])

# convert the new clustered colors to hex
cluster_keys <- rgb(
	clusters$centers[,'red'],
 	clusters$centers[,'green'],
	clusters$centers[,'blue'],
	maxColorValue=255)

# add them to the df, add the x and y axes values
dominant_color_df <- dominant_color_df %>%
	mutate(new_hex = cluster_keys[ clusters$cluster],
	color_name = clusters$cluster) %>%
	separate(col='tile', into=c('x', 'y'), sep='x', remove=FALSE)

# x and y must be integers to be displayed in correct order
dominant_color_df[['x']] <- as.integer(dominant_color_df[['x']])
dominant_color_df[['y']] <- as.integer(dominant_color_df[['y']])
```

## Overview of tiled picture

Below is the result of tiling and color-clustering, to have at most
`r cfg[['color_number']][['value']]` colors.

For easier quilt assembly, the full picture is divided in 8x8 tiles blocks.

```{r display_result, results='asis'}
# first, figure out the breaks every 8 rows or columns. Using geom_tile so the
# breaks should be at 0.5, 8.5, 16.5, ...
grid_x_breaks <- seq(0.5, cfg[['tile_number_width']][['value']], by = 8)
grid_y_breaks <- seq(0.5, cfg[['tile_number_height']][['value']], by = 8)

# after clustering
plot_tiles(dominant_color_df) +
	geom_vline(xintercept = grid_x_breaks, color = "black", linewidth = 1) +
	geom_hline(yintercept = grid_y_breaks * -1, color = "black", linewidth = 1)
```

## Fabric requirements

Below is the swatch of colors with number of squares / tiles needed,
and translated into yardage. Fat quarters are 18x22". The yardage includes a 1/4"
seam allowance.

Cut the specified number of `r (cfg[['tile_size']][['value']] + 0.5)`" squares per color.


```{r fatquarter}
# how many tiles in a fat quarter?
# with a 1/4 inch seam allowance
fq_width <- 22
fq_height <- 18
raw_tile <- cfg[['tile_size']][['value']] + 0.25

tile_in_fq <- floor(fq_width / raw_tile) * floor(fq_height / raw_tile)
```

<div class = "row">
<div class = "column" style="float: left; width: 70%;">

```{r display_swatch, results='asis'}
# count how many tiles are needed from each color
totals <- get_totals(dominant_color_df)

plot_tiles(totals, label=TRUE) + 
	theme(theme(aspect.ratio=3/cfg[['color_number']][['value']]))
```

</div>

<div class = "column" style="float: left; width: 30%;">

```{r swatch_table, results='asis'}
knitr::kable(totals %>% select(-new_hex, -x, -y), row.names=FALSE)
```

</div>
</div>


## General assembly remarks

For easier assembly, first sew together 8 tiles x 8 tiles blocks, then sew rows of blocks, and
finally sew rows together.

```{r assembly, results='asis'}
# create df of blocks with their number
block_df <- data.frame(list(
	x = rep(seq(1:length(grid_x_breaks)), length(grid_y_breaks)),
	y = rep(1:length(grid_y_breaks), each = length(grid_x_breaks)),
	color_name = paste0('block ', 1:(length(grid_x_breaks)*length(grid_y_breaks))),
	'new_hex' = 'white'
	))

plot_tiles(block_df)+
	geom_text(aes(label=color_name))
```


## Blocks assembly

Below are instructions for making each of the 8x8 blocks.

```{r blocks, results='asis'}
# iterate over the blocks
i <- 0

for (block_col_i in grid_y_breaks+0.5) {
	for (block_row_i in grid_x_breaks+0.5) {
		i <- i + 1
		cat(paste0('\n\n### Block ', i, '\n\n'))
		block_i <- dominant_color_df %>%
			filter(x %in% block_row_i:(block_row_i+7), y %in% block_col_i:(block_col_i+7))

		print(plot_tiles(block_i, label=TRUE))

		totals <- get_totals(block_i)

		print(knitr::kable(totals %>% select(-new_hex, -x, -y), row.names=FALSE))
	}
}
```


